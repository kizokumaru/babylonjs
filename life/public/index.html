<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>NFT LIFE</title>
</head>

<body>
    <canvas class="mb-0 in-viewport" id="canvas" width=100% height="100%"> Your browser does not support the HTML5
        canvas tag. </canvas>
    <div id="numalive">0</div>
    <script>
        var canvas = document.getElementById('canvas');
        canvas.width = 3840;
        canvas.height = 2160;
        var probability = 0.10;
        class Cell {

            static width = 10;
            static height = 10;

            constructor(context, gridX, gridY) {
                this.context = context;

                // Store the position of this cell in the grid
                this.gridX = gridX;
                this.gridY = gridY;
                this.color = "#" + Math.floor(Math.random() * 16777215).toString(16);
                // Make random cells alive
                this.alive = Math.random() > probability;
            }

            draw() {
                // Draw a simple square
                this.context.fillStyle = this.alive ? this.color : "#000000";
                this.context.fillRect(this.gridX * Cell.width, this.gridY * Cell.height, Cell.width, Cell.height);
            }
        }

        class GameWorld {

            static numColumns = canvas.width / 10;
            static numRows = canvas.height / 10;
            //static numColumns = 10;
            //static numRows = 10;

            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.context = this.canvas.getContext('2d');
                this.gameObjects = [];
                this.numCellsAlive = 0;
                this.state = true;
                this.aliveAtStart = 0;
                this.startDate = new Date();
                this.endDate = null;
                this.ratio_ant = 0;
                this.seconds = 0;
                this.statetime = true;
                this.countratio = 5;

                this.createGrid();

                // Request an animation frame for the first time
                // The gameLoop() function will be called as a callback of this request
                window.requestAnimationFrame(() => this.gameLoop());
            }

            createGrid() {
                for (let y = 0; y < GameWorld.numRows; y++) {
                    for (let x = 0; x < GameWorld.numColumns; x++) {
                        this.gameObjects.push(new Cell(this.context, x, y));
                    }
                }
            }

            isAlive(x, y) {
                if (x < 0 || x >= GameWorld.numColumns || y < 0 || y >= GameWorld.numRows) {
                    return false;
                }

                return this.gameObjects[this.gridToIndex(x, y)].alive ? 1 : 0;
            }

            gridToIndex(x, y) {
                return x + (y * GameWorld.numColumns);
            }

            checkSurrounding() {
                // Loop over all cells
                for (let x = 0; x < GameWorld.numColumns; x++) {
                    for (let y = 0; y < GameWorld.numRows; y++) {

                        // Count the nearby population
                        let numAlive = this.isAlive(x - 1, y - 1) + this.isAlive(x, y - 1) + this.isAlive(x + 1, y - 1) + this.isAlive(x - 1, y) + this.isAlive(x + 1, y) + this.isAlive(x - 1, y + 1) + this.isAlive(x, y + 1) + this.isAlive(x + 1, y + 1);
                        let centerIndex = this.gridToIndex(x, y);

                        if (numAlive == 2) {
                            // Do nothing
                            this.gameObjects[centerIndex].nextAlive = this.gameObjects[centerIndex].alive;
                        } else if (numAlive == 3) {
                            // Make alive
                            this.gameObjects[centerIndex].nextAlive = true;
                            this.numCellsAlive--;
                        } else {
                            // Make dead
                            this.gameObjects[centerIndex].nextAlive = false;
                            this.numCellsAlive++;
                        }
                    }
                }

                // Apply the new state to the cells
                for (let i = 0; i < this.gameObjects.length; i++) {
                    this.gameObjects[i].alive = this.gameObjects[i].nextAlive;
                }
            }

            gameLoop() {
                // Check the surrounding of each cell
                this.numCellsAlive = 0;
                this.checkSurrounding();
                let divAlive = document.getElementById("numalive");
                let total = (GameWorld.numColumns * GameWorld.numRows);
                let death = this.numCellsAlive;
                let alive = total - death;
                let ratio = alive / total * 100;


                if (this.state == true) {
                    this.aliveAtStart = alive;
                    this.state = false;
                }

                if (ratio.toFixed(2).toString() == this.ratio_ant.toFixed(2).toString() && this.statetime) {
                    this.endDate = new Date();
                    this.seconds = (this.endDate.getTime() - this.startDate.getTime()) / 1000;

                    if (this.countratio < 1) {
                        this.statetime = false;
                    } else { this.countratio--; }
                } else {
                    this.ratio_ant = ratio;
                }

                divAlive.innerText = "BLOCKS: " + total + "\n DEATHS: " + death + "\n ALIVE: " + alive + "\n RATIO: " + ratio.toFixed(2)
                    + "\n PROBABILITY AT START: " + probability
                    + "\n ALIVE AT START: " + this.aliveAtStart
                    + "\n START TIME: " + this.startDate.toUTCString()
                    + "\n END TIME: " + (this.endDate==null?null:this.endDate.toUTCString())
                    + "\n TIME OF CHANGE: " + this.seconds.toFixed(0) + " seconds"

                    ;


                // Clear the screen
                this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw all the gameobjects
                for (let i = 0; i < this.gameObjects.length; i++) {
                    this.gameObjects[i].draw();
                }

                // The loop function has reached it's end, keep requesting new frames
                setTimeout(() => {
                    window.requestAnimationFrame(() => this.gameLoop());
                }, 500)
            }
        }

        window.onload = () => {
            // The page has loaded, start the game
            let gameWorld = new GameWorld('canvas');

        }

    </script>
</body>

</html>